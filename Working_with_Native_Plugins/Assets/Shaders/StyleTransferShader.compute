// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ProcessInput
#pragma kernel ProcessOutput
#pragma kernel Merge
#pragma kernel FlipXAxis
#pragma kernel FlipYAxis
//#pragma kernel FlipDiag


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<half4> Result;
// Stores the input image and is set with cs.SetTexture
Texture2D<half4> InputImage;

// Stores the depth data from the StyleDepth camera
Texture2D<half4> StyleDepth;
// Stores the depth data from the SourceDepth camera
Texture2D<half4> SrcDepth;
// Store the original image from the current frame
Texture2D<half4> SrcImage;

[numthreads(4, 4, 1)]
void ProcessInput(uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = half4((InputImage[id.xy].x * 255.0h),
        (InputImage[id.xy].y * 255.0h),
        (InputImage[id.xy].z * 255.0h), 1.0h);
}

[numthreads(4, 4, 1)]
void ProcessOutput(uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = half4((clamp(InputImage[id.xy].x, 0.0f, 255.0f) / 255.0f),
        (clamp(InputImage[id.xy].y, 0.0f, 255.0f) / 255.0f),
        (clamp(InputImage[id.xy].z, 0.0f, 255.0f) / 255.0f), 1.0h);
}

[numthreads(4, 4, 1)]
void Merge(uint3 id : SV_DispatchThreadID)
{
    bool match = StyleDepth[id.xy].x == SrcDepth[id.xy].x;

    if (match && (StyleDepth[id.xy].x > 0)) {
        Result[id.xy] = half4(InputImage[id.xy].r, InputImage[id.xy].g, InputImage[id.xy].b, InputImage[id.xy].a);
    }
    else {
        Result[id.xy] = half4(SrcImage[id.xy].r, SrcImage[id.xy].g, SrcImage[id.xy].b, SrcImage[id.xy].a);
    }
}


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWTexture2D<float4> Result;

// Stores the original image
//Texture2D<float4> InputImage;

// The height of the input image
int height;
// The width of the input image
int width;
// Stores the new location for individual pixel values
int2 coords;

[numthreads(4, 4, 1)]
void FlipXAxis(uint3 id : SV_DispatchThreadID)
{
    // Update the y value for the pixel coordinates
    coords = int2(id.x, height - id.y);
    Result[id.xy] = float4(InputImage[coords].x, InputImage[coords].y, InputImage[coords].z, 1.0f);
}

[numthreads(4, 4, 1)]
void FlipYAxis(uint3 id : SV_DispatchThreadID)
{
    // Update the x value for the pixel coordinates
    coords = int2(width - id.x, id.y);
    Result[id.xy] = float4(InputImage[coords].x, InputImage[coords].y, InputImage[coords].z, 1.0f);
}

//[numthreads(8, 8, 1)]
//void FlipDiag(uint3 id : SV_DispatchThreadID)
//{
//    // Swap the x and y coordinate values
//    coords = int2(id.y, id.x);
//    Result[id.xy] = float4(InputImage[coords].x, InputImage[coords].y, InputImage[coords].z, 1.0f);
//}